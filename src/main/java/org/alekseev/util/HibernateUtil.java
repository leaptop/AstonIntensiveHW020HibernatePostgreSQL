package org.alekseev.util;

import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

/**
 * HibernateUtil — инфраструктурный класс, который управляет "фабрикой сессий"
 * Hibernate.
 *
 * Главная идея:
 * 1) SessionFactory — тяжёлый объект, который создаётся долго (читает конфиг,
 *    поднимает сервисы Hibernate, настраивает пул соединений и т.д.). Поэтому его
 *    создают один раз на всё приложение.
 *
 * 2) DAO-слой (например, UserDaoHibernate) не должен каждый раз пересобирать
 *    фабрику, он просто просит её у HibernateUtil и открывает "Session" для
 *    конкретной операции.
 *
 * 3) В прод-режиме фабрика строится из hibernate.cfg.xml
 *    (там прописан localhost:5432). Это удобно для запуска приложения вручную
 *    через docker-compose.
 *
 * 4) В интеграционных тестах нам нельзя жёстко зависеть от localhost:5432:
 *    Testcontainers поднимает PostgreSQL в Docker и отдаёт нам JDBC URL/логин/
 *    пароль динамически. Поэтому тесту нужно уметь "подложить" свою
 *    SessionFactory, собранную на параметрах контейнера.
 *
 * Важно про "что меняется в памяти vs в БД":
 * - HibernateUtil сам по себе НЕ меняет данные в БД.
 * - Он только создаёт инфраструктуру (SessionFactory), через которую DAO потом
 *   будет делать транзакции и SQL.
 *
 * Почему это не Spring:
 * - В Spring обычно этим управляет контейнер (DI + lifecycle).
 * - Здесь мы делаем вручную: static singleton + ручное закрытие.
 *
 * - SessionFactory — это "завод", который умеет создавать Session.
 * - Session — это рабочий объект Hibernate для одной операции/одной "единицы
 *   работы" с БД (обычно на время одного DAO-метода).
 * - Реальные изменения в БД происходят не в HibernateUtil, а когда DAO внутри
 *   транзакции делает commit. Именно commit обычно вызывает flush, то есть
 *   отправку SQL в БД.
 */
public final class HibernateUtil {

    /**
     * volatile означает:
     * 1) значение поля будет "правильно видно" между потоками
     *    (если бы приложение было многопоточным),
     * 2) это важно в схеме "double-check locking" ниже.
     *
     * На практике в учебном консольном приложении это почти не критично,
     * но это типичный шаблон безопасного ленивого singleton.
     *
     * Дополнение:
     * - "ленивый" означает: фабрика создаётся только при первом обращении,
     *   а не при загрузке класса.
     * - "singleton" означает: один объект SessionFactory на всю JVM.
     * - Это экономит время старта и ресурсы, потому что SessionFactory тяжёлая.
     */
    private static volatile SessionFactory sessionFactory;

    private HibernateUtil() {
        // Закрываем возможность сделать new HibernateUtil().
        // Эффект: класс используется только как "набор статических методов"
        // (утилита).
        //
        // Дополнение:
        // - Это защищает от случайного создания экземпляров и путаницы
        //   "а где хранится фабрика".
        // - У нас один источник правды: static поле sessionFactory.
    }

    /**
     * Получить SessionFactory.
     *
     * Что делаем:
     * - Если фабрика ещё не создана, читаем hibernate.cfg.xml и создаём её.
     * - Если уже создана — возвращаем существующую.
     *
     * Зачем:
     * - SessionFactory должна быть одна на приложение, иначе будут лишние
     *   ресурсы и проблемы с соединениями.
     *
     * Эффект снаружи:
     * - DAO всегда работает через одну и ту же фабрику.
     *
     * Дополнение:
     * - Здесь используется "double-check locking", то есть:
     *   1) быстрый null-check без блокировок,
     *   2) затем synchronized,
     *   3) затем повторный null-check внутри блокировки.
     * - Это нужно, чтобы фабрика не была создана дважды, если два потока
     *   одновременно впервые вызывают этот метод.
     */
    public static SessionFactory getSessionFactory() { // public: доступен из любого места (DAO/Service/UI)

        if (sessionFactory == null) {
            // Мы ещё не создали фабрику. Пока это только проверка в памяти,
            // никаких действий с БД не происходит.
            synchronized (HibernateUtil.class) {
                // synchronized блокирует создание фабрики "по одному".
                // Это предотвращает гонку (race condition), когда фабрику
                // могли бы создать дважды.

                if (sessionFactory == null) {
                    // Повторная проверка нужна, потому что другой поток мог
                    // успеть создать фабрику, пока текущий поток ждал монитор.

                    sessionFactory = new Configuration()
                            .configure()
                            .buildSessionFactory();

                    // Shutdown hook — страховка:
                    // Что делаем: регистрируем код, который закроет фабрику
                    // при завершении JVM.
                    // Зачем: даже если ты "забыл" закрыть фабрику в main,
                    // ресурсы всё равно освободятся.
                    //
                    // Дополнение:
                    // - "Shutdown hook" — это специальный поток/коллбек,
                    //   который JVM вызовет при завершении процесса.
                    // - Это помогает особенно в тестах и при аварийных
                    //   завершениях, когда забыли вызвать shutdown вручную.
                    Runtime.getRuntime().addShutdownHook(
                            new Thread(HibernateUtil::shutdown)
                    );
                }
            }
        }

        return sessionFactory;
    }

    /**
     * Корректно закрыть SessionFactory.
     *
     * Что делаем:
     * - Если фабрика существует и ещё не закрыта, вызываем close().
     *
     * Зачем:
     * - Hibernate держит ресурсы (пулы соединений, внутренние сервисы).
     * - Если не закрывать — в тестах это может приводить к утечкам и странным
     *   ошибкам при повторных запусках.
     *
     * Эффект снаружи:
     * - Соединения с БД закрыты, контейнер/приложение могут завершиться чисто.
     *
     * Дополнение:
     * - close() не "удаляет" данные из БД и не делает rollback.
     * - close() просто освобождает ресурсы клиента (со стороны приложения).
     */
    public static void shutdown() {
        if (sessionFactory != null && !sessionFactory.isClosed()) {
            sessionFactory.close();
        }
    }

    /**
     * ТЕСТОВЫЙ ХУК: подменить SessionFactory.
     *
     * Что делаем:
     * - Закрываем текущую фабрику (если была), чтобы не держать соединения
     *   на "старую" БД.
     * - Присваиваем sessionFactory = testSessionFactory.
     *
     * Зачем:
     * - Интеграционные тесты должны работать с PostgreSQL из Testcontainers,
     *   а не с твоей локальной БД.
     * - Testcontainers выдаёт JDBC URL/логин/пароль, и на их основе тест
     *   собирает фабрику.
     *
     * Эффект снаружи:
     * - Все DAO, которые вызывают HibernateUtil.getSessionFactory(), начнут
     *   работать через тестовую БД контейнера.
     *
     * Важно:
     * - Это просто подмена ссылки в памяти JVM.
     * - Данные в БД от этого не меняются напрямую; меняется только то, КУДА
     *   будут ходить DAO.
     *
     * Дополнение:
     * - "Хук" здесь означает: специальная точка расширения, которую мы
     *   используем в тестах, чтобы управлять инфраструктурой.
     * - В прод-коде этот метод обычно не вызывается, потому что прод-код
     *   и так читает конфиг из hibernate.cfg.xml.
     */
    public static void setSessionFactoryForTests(SessionFactory testSessionFactory) {
        shutdown();
        sessionFactory = testSessionFactory;
    }

    /**
     * ТЕСТОВЫЙ ХУК: полностью сбросить SessionFactory.
     *
     * Что делаем:
     * - Закрываем фабрику и ставим поле sessionFactory в null.
     *
     * Зачем:
     * - Иногда тестам нужно гарантированно начать "с чистого листа"
     *   (например, если меняются параметры подключения между тестовыми наборами).
     *
     * Эффект снаружи:
     * - Следующий вызов getSessionFactory() снова прочитает hibernate.cfg.xml
     *   и создаст новую фабрику (если тест заранее не подложит свою через
     *   setSessionFactoryForTests()).
     *
     * Дополнение:
     * - Этот метод удобен, когда тесты запускаются пачками и ты хочешь
     *   исключить влияние старых соединений/конфигураций.
     * - Это опять же изменение только в памяти JVM; никаких изменений в БД
     *   само по себе оно не делает.
     */
    public static void resetForTests() {
        shutdown();
        sessionFactory = null;
    }
}