package org.alekseev.dao;

import org.alekseev.entity.User;

import java.util.List;
import java.util.Optional;

/**
 * UserDao — контракт (интерфейс) доступа к данным User.
 *
 * Почему интерфейс полезен:
 * - можно заменить реализацию (например, JDBC вместо Hibernate)
 * - легче тестировать (можно подменить мок-реализацией)
 *
 * CRUD:
 * C (Create)  -> create(...)
 * R (Read)    -> findById(...), findAll()
 * U (Update)  -> updateById(...)
 * D (Delete)  -> deleteById(...)
 */
public interface UserDao {

    /**
     * Создаёт пользователя в БД.
     * Возвращаем id созданной записи.
     */
    Long create(User user);

    /**
     * Ищем пользователя по id.
     * Optional: потому что пользователь может не существовать.
     */
    Optional<User> findById(Long id);

    /**
     * Получить всех пользователей.
     */
    List<User> findAll();

    /**
     * Обновить поля пользователя по id.
     *
     * что это за задача "обновить пользователя по айди"?
     * “Обновить пользователя по id” — это просто операция Update из CRUD, где ты говоришь:
     * “В таблице users найди строку, у которой id = ..., и измени у неё некоторые поля (name/email/age).”
     * Как это выглядит на уровне базы (SQL)
     * Пример: хотим у пользователя с id = 5 поменять имя и возраст:
     * UPDATE users
     * SET name = 'Stepan', age = 39, email = 'stepan@example.com'
     * WHERE id = 5;
     * id тут играет роль уникального идентификатора строки (первичный ключ).
     * Поэтому по id мы точно знаем, какую запись менять.
     * Как это выглядит в твоём приложении (Hibernate-логика)
     * Пользователь в консоли выбирает “Update”.
     * Вводит id и новые значения.
     * DAO делает примерно так:
     * открывает Session
     * начинает Transaction
     * загружает пользователя по id (session.get(User.class, id))
     * меняет поля (setName/setEmail/setAge)
     * commit() → Hibernate превращает изменения в SQL UPDATE
     *
     *
     * Мы НЕ принимаем User целиком по двум причинам:
     * 1) User может быть "detached" (оторван от Session), и новичку легко запутаться.
     * 2) Этот метод демонстрирует важную вещь Hibernate: dirty checking (авто-обновление).
     *
     *
     *  Что такое dirty checking (авто-обновление)
     * Dirty checking = “проверка на грязь” (на изменения).
     * Идея такая:
     * Hibernate загружает объект из БД → делает “снимок” его состояния (условно: какие поля
     * и какие значения).
     * Ты меняешь поля у managed-объекта обычными сеттерами:
     * user.setName(newName);
     * Перед commit() Hibernate сравнивает:
     *  что было в снимке
     *  что стало сейчас
     * Если есть отличия → Hibernate сам генерирует SQL UPDATE.
     * То есть тебе НЕ нужно делать:
     * session.update(user);
     * если user уже managed внутри Session.
     *
     *
     * Что значит detached (оторван от Session)
     * Ключевой термин: состояния Entity в Hibernate
     * Один и тот же объект User в программе может быть в разных состояниях:
     * transient (новый)
     * Ты сделал new User(...), но в БД его ещё нет, Hibernate его не “знает”.
     * persistent / managed (управляемый)
     * Объект загружен/создан внутри текущей Session и Hibernate за ним следит.
     * detached (оторванный)
     * Объект когда-то был managed, но Session уже закрыли — и теперь объект “сам по себе”.
     * removed (помечен на удаление)
     * Hibernate знает, что его нужно удалить при commit.
     */
    void updateById(Long id, String newName, String newEmail, Integer newAge);

    /**
     * Удалить пользователя по id.
     * Если пользователя нет — можно сделать no-op или бросить исключение.
     * no-op (произносится “ноу-оп”) = no operation = “никакого действия”.
     * Если ты вызвал deleteById(123), а пользователя с id=123 в базе нет, то можно ничего не делать и просто
     * молча завершить метод.
     * То есть метод отработает “успешно”, но фактически ничего не удалил, потому что удалять было нечего.
     * Как это выглядит на практике
     * Вариант 1 — no-op (молча)
     * public void deleteById(Long id) {
     *     User user = session.get(User.class, id);
     *     if (user == null) {
     *         return; // no-op: ничего не делаем
     *     }
     *     session.remove(user);
     * }
     *
     *
     * Плюс: проще, не считаешь отсутствие пользователя ошибкой.
     * Минус: в консольном приложении пользователь может подумать “удалилось”, хотя удалять было нечего.
     */
    void deleteById(Long id);
}
